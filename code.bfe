%{
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "gentree.h"
#include "assembly.h"
%}

%start stat
%term OP_REG = 1 OP_NUM = 2 OP_ID = 3 OP_ADD = 4 OP_MULT = 5 OP_NEG = 6 OP_UNARY = 7 OP_OR = 8 OP_GREATER = 9 OP_HASH = 10 OP_ASSIGN = 11 OP_RETURN = 12

%%

stat: num
stat: reg

num: OP_UNARY(num, num)             # 1 #   bnode->val = kids[0]->val * kids[1]->val;
num: OP_MULT(num, num)              # 1 #   bnode->val=kids[0]->val * kids[1]->val;
num: OP_ADD(num, num)               # 1 #   bnode->val=kids[0]->val + kids[1]->val;
num: OP_OR(num, num)                # 1 #   bnode->val = kids[0]->val | kids[1]->val;
num: OP_GREATER(num, num)           # 1 #   bnode->val = kids[0]->val > kids[1]->val ? -1 : 0;
num: OP_HASH(num, num)              # 1 #   bnode->val = kids[0]->val != kids[1]->val ? -1 : 0;

num: OP_ASSIGN(OP_ID, num)          # 1 #   writeDecleration(bnode->kids[0]->val, bnode->kids[1]->val);

reg: OP_ASSIGN(OP_ID, reg)          # 1 #   writeDeclerationReg(bnode->kids[0]->val, bnode->kids[1]->regname);

reg: OP_RETURN(num)                 # 1 #   writeReturnNum(kids[0]->val);
reg: OP_RETURN(reg)                 # 1 #   writeReturnReg(kids[0]->regname);

reg: OP_ADD(reg, num)               # 1 #   bnode->regname = bnode->kids[0]->regname; writeOpNumReg("addq", kids[0]->regname, kids[1]->val);
reg: OP_MULT(reg, num)              # 1 #   bnode->regname = kids[0]->regname; writeOpNumReg("imulq", kids[0]->regname, kids[1]->val);
reg: OP_OR(reg, num)              # 1 #   bnode->regname = kids[0]->regname; writeOpNumReg("or", kids[0]->regname, kids[1]->val);

reg: OP_ADD(num, reg)               # 1 #   bnode->regname = bnode->kids[1]->regname; writeOpNumReg("addq", kids[1]->regname, kids[0]->val);
reg: OP_MULT(num, reg)              # 1 #   bnode->regname = kids[1]->regname; writeOpNumReg("imulq", kids[1]->regname, kids[0]->val);
reg: OP_OR(num, reg)              # 1 #   bnode->regname = kids[1]->regname; writeOpNumReg("or", kids[1]->regname, kids[0]->val);


reg: OP_ADD(reg, reg)               # 1 #   bnode->regname = kids[0]->regname; writeOpRegReg("addq", kids[0]->regname, kids[1]->regname);
reg: OP_MULT(reg, reg)              # 1 #   bnode->regname = kids[0]->regname; writeOpRegReg("imulq", kids[0]->regname, kids[1]->regname);
reg: OP_OR(reg, reg)              # 1 #   bnode->regname = kids[0]->regname; writeOpRegReg("or", kids[0]->regname, kids[1]->regname);


num: OP_NEG(num)                    # 1 #   bnode->val = -1*kids[0]->val;

num:	OP_NUM                      
reg:    OP_ID                       # 1 #   if(bnode->regname != NULL && bnode->val != -1) {writeLoadId(bnode->val, bnode->regname);}

%%

extern treenode *root;
extern int yyparse(void);
void burm_reduce(NODEPTR_TYPE bnode, int goalnt);

void invoke_burm(NODEPTR_TYPE root) {
    burm_label(root);
    burm_reduce(root, 1);
}